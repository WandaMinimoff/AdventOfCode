#!/usr/bin/python3
# file created 2024-Dec-09 07:55
"""https://adventofcode.com/2024/day/09"""

from collections import deque, namedtuple
from heapq import heappush, heappop

DATA = 'data202409.txt'
# DATA = 'testdata202409.txt'


def GetData(datafile):
  """Read input into a list of lines."""
  lines = []
  with open(datafile, 'r') as fh:
    lines = [i.strip() for i in fh]
  return lines


def PositionAndPopdirection(line):
  """For Part 1, given the original line, figure out for each index whether
     that block will come from the left of the deque or the right."""
  num = iter(line)
  pos = 0
  direction = 'LEFT'
  while True:
    try:
      for _ in range(int(next(num))):
        yield pos, direction
        pos += 1
      direction = 'RIGHT' if direction == 'LEFT' else 'LEFT'

    except StopIteration:
      pass


def BuildDeque(line):
  """Deque built from every other item in the line starting at idx 0.
     Create a list of the number of IDs in that block, then extend
     the deque with that list."""
  disk_deque = deque([])
  for i in range(len(line)//2 + 1):
    idx = i
    num = int(line[idx * 2])
    sub_list = [idx for _ in range(num)]
    disk_deque.extend(sub_list)
  return disk_deque


def Part1(original_line):
  """Part 1."""
  big_deque = BuildDeque(original_line)
  pos_and_dir = PositionAndPopdirection(original_line)
  checksum = 0
  while big_deque:
    idx, direction = next(pos_and_dir)
    value = big_deque.pop() if direction == 'RIGHT' else big_deque.popleft()
    checksum += idx * value
  return checksum


def Expand(line):
  """Represent the whole filesystem as a single list."""
  final = []
  for idx, val in enumerate(line):
    if not idx % 2:
      addval = idx//2
    else:
      addval = None
    for _ in range(val):
      final.append(addval)
  return final


def ID_to_Len(line):
  """Based on BuildDeque but a tuple of (id, len)."""
  all_files = []
  for i in range(len(line)//2 + 1):
    idx = i
    file_len = int(line[idx * 2])
    all_files.append((idx, file_len))
  return all_files


def IndicesOfFilesAndSpaces(line):
  """Files is a list of (value, size, location on disk) and
     Spaces is a dictionary of {size: heapq([l1, l3, l2])} where
     the value is a heap and heap[0] is the lowest (leftmost) location.
  """
  File = namedtuple('F', 'value size location')
  files = []
  spaces = {i:[] for i in range(1, 10)}
  loc_on_disk = 0
  for i, val in enumerate(line):
    if not i % 2:
      current_idx_of_file = i//2
      f = File(value=current_idx_of_file, size=val, location=loc_on_disk)
      files.append(f)
      loc_on_disk += val
    else:
      if val:
        heappush(spaces[val], loc_on_disk)
      loc_on_disk += val
  return files[::-1], spaces


def PrintDisk(disk):
  """Print out the whole disk (part 2). Works well for test data."""
  for i in disk:
    print(i if i is not None else '.', end='')
  print()


def FindLeftmostSpace(spaces, filetuple):
  """Return leftmost valid space for a given filetuple.

  Args:
    spaces: (dict) {size: heap([l1, l3, l2])}
    filetuple: (value, size, location)


  Side effects: in the dict of spaces, all keys of filetuple.size or more
    will be purged of indices greater than or equal to filetuple.location.

  Returns:
    namedtuple (location, size)
  """
  sp_tuple = namedtuple('space', 'location, size')
  contenders = []
  for i in range(filetuple.size, 10):
    sp_heap = spaces[i]

    # clear out spaces that are greater than current location
    while sp_heap and sp_heap[0] >= filetuple.location:
      heappop(sp_heap)

    if sp_heap:
      contenders.append((sp_tuple(sp_heap[0], i)))

  contenders.sort()
  if contenders:
    return sorted(contenders)[0]
  return None


def MoveFile(disk, filetuple, spaces, dest):
  """Move the file on disk to the space given by dest.
     This modifies both disk and spaces.
  """
  # pop the space from the heap of spaces. assert this is the one we wanted.
  assert heappop(spaces[dest.size]) == dest.location

  # erase old file location
  for idx in range(filetuple.location, filetuple.location + filetuple.size):
    disk[idx] = None

  # add to destination location
  for idx in range(dest.location, dest.location + filetuple.size):
    disk[idx] = filetuple.value

  # if there is leftover space, update the heap for spaces of the new size.
  leftover_size = dest.size - filetuple.size
  if leftover_size:
    leftover_location = dest.location + filetuple.size
    heappush(spaces[leftover_size], leftover_location)

  return disk


def Defrag(disk, files, spaces):
  """Defrag the disk per Part 2 instructions.
  Args:
    disk (list):  A list representing every position on the disk. Each
                  element is the original ID of the file that the block
                  belongs to, or None if it is empty space.
                  Generated by Expand().
    files (list): A list of tuples(value, size, location) where location
                  is the index the first block on the disk and value is the
                  original ID that the block belonged to. Size is the
                  length of the file in blocks. The list is ordered so that
                  the rightmost original file is leftmost in the list.
    spaces(dict): A dictionary, keyed on size, of all the empty space on
                  the disk. Spaces can be of size between 1 and 9, inclusive.
                  The value of space[i] is a heap of all the indices on disk
                  of spaces of size i.
  """
  for filetuple in files:
    dest = FindLeftmostSpace(spaces, filetuple)
    if dest is not None:
      MoveFile(disk, filetuple, spaces, dest)
  return disk


def GetChecksum(disk):
  """Given a list representation of the whole disk, with None as the
     value for empty space, return the checksum."""
  total = 0
  for idx, val in enumerate(disk):
    if val is not None:
      total += idx * val
  return total


def Part2(original_line):
  """Part 2."""
  line = [int(i) for i in original_line]
  files, spaces = IndicesOfFilesAndSpaces(line)
  disk = Expand(line)
  disk = Defrag(disk, files, spaces)
  answer = GetChecksum(disk)
  return answer


def main():
  """main"""
  lines = GetData(DATA)
  print(f'Part 1: {Part1(lines[0])}')
  print(f'Part 2: {Part2(lines[0])}')


if __name__ == '__main__':
  main()
